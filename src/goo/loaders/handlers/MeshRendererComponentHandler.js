// Generated by CoffeeScript 1.4.0
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['goo/loaders/handlers/ConfigHandler', 'goo/loaders/handlers/ComponentHandler', 'goo/loaders/Loader', 'goo/entities/components/MeshRendererComponent', 'goo/entities/components/MeshDataComponent', 'goo/renderer/Material', 'goo/renderer/Util', 'goo/renderer/shaders/ShaderLib', 'goo/util/rsvp', 'goo/util/PromiseUtil', 'goo/util/ObjectUtil'], function(ConfigHandler, ComponentHandler, Loader, MeshRendererComponent, MeshDataComponent, Material, Util, ShaderLib, RSVP, pu, _) {
  var MaterialHandler, MeshRendererComponentHandler, ShaderHandler;
  MaterialHandler = (function(_super) {

    __extends(MaterialHandler, _super);

    MaterialHandler._register('material');

    function MaterialHandler(world, getConfig, updateObject, options) {
      this.world = world;
      this.getConfig = getConfig;
      this.updateObject = updateObject;
      this.options = options;
      this._objects = {};
    }

    MaterialHandler.prototype._prepare = function(config) {
      var _ref, _ref1, _ref2, _ref3;
      if ((_ref = config.blendState) == null) {
        config.blendState = {};
      }
      _.defaults(config.blendState, {
        blending: 'NoBlending',
        blendEquation: 'AddEquation',
        blendSrc: 'SrcAlphaFactor',
        blendDst: 'OneMinusSrcAlphaFactor'
      });
      if ((_ref1 = config.cullState) == null) {
        config.cullState = {};
      }
      _.defaults(config.cullState, {
        enabled: true,
        cullFace: 'Back',
        frontFace: 'CCW'
      });
      if ((_ref2 = config.depthState) == null) {
        config.depthState = {};
      }
      _.defaults(config.depthState, {
        enabled: true,
        write: true
      });
      return (_ref3 = config.renderQueue) != null ? _ref3 : config.renderQueue = -1;
    };

    MaterialHandler.prototype._create = function(ref) {
      var _ref;
      if ((_ref = this._objects) == null) {
        this._objects = {};
      }
      return this._objects[ref] = new Material(ref);
    };

    MaterialHandler.prototype.update = function(ref, config) {
      var object, _ref,
        _this = this;
      this._prepare(config);
      if (!((_ref = this._objects) != null ? _ref[ref] : void 0)) {
        this._create(ref);
      }
      object = this._objects[ref];
      return this._getShaderObject(config.shaderRef, config.wireframe).then(function(shader) {
        var name, promises, textureRef, value, _fn, _i, _len, _ref1, _ref2, _ref3;
        if (!shader) {
          console.warn('Unknown shader', config.shaderRef, '- not updating material', ref);
          return;
        }
        if (config.wireframeColor) {
          object.wireframeColor = Util.clone(config.wireframeColor);
        }
        object.blendState = Util.clone(config.blendState);
        object.cullState = Util.clone(config.cullState);
        object.depthState = Util.clone(config.depthState);
        if (config.renderQueue === -1) {
          object.renderQueue = null;
        } else {
          object.renderQueue = config.renderQueue;
        }
        object.shader = shader;
        object.uniforms = {};
        _ref1 = config.uniforms;
        for (name in _ref1) {
          value = _ref1[name];
          object.uniforms[name] = _.clone(value);
        }
        promises = [];
        if ((_ref2 = config.textureRefs) != null ? _ref2.length : void 0) {
          _ref3 = config.textureRefs;
          _fn = function(textureRef) {
            return promises.push(_this.getConfig(textureRef).then(function(textureConfig) {
              return _this.updateObject(textureRef, textureConfig, _this.options).then(function(texture) {
                return {
                  ref: textureRef,
                  texture: texture
                };
              });
            }));
          };
          for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
            textureRef = _ref3[_i];
            _fn(textureRef);
          }
        }
        if (promises != null ? promises.length : void 0) {
          return RSVP.all(promises).then(function(textures) {
            var texture, tlist, _j, _len1;
            tlist = [];
            for (_j = 0, _len1 = textures.length; _j < _len1; _j++) {
              texture = textures[_j];
              tlist[config.textureRefs.indexOf(texture.ref)] = texture.texture;
            }
            object.textures = tlist;
            return object;
          }).then(null, function(err) {
            return console.error("Error loading textures: " + err);
          });
        } else {
          return object;
        }
      });
    };

    MaterialHandler.prototype._getShaderObject = function(ref, wireframe) {
      var promise, shader,
        _this = this;
      if (wireframe) {
        promise = new RSVP.Promise();
        shader = Material.createShader(ShaderLib.simple);
        promise.resolve(shader);
        return promise;
      } else {
        return this.getConfig(ref).then(function(config) {
          return _this.updateObject(ref, config, _this.options);
        });
      }
    };

    return MaterialHandler;

  })(ConfigHandler);
  ShaderHandler = (function(_super) {

    __extends(ShaderHandler, _super);

    function ShaderHandler() {
      return ShaderHandler.__super__.constructor.apply(this, arguments);
    }

    ShaderHandler._register('shader');

    ShaderHandler.prototype._create = function(ref) {
      var _ref;
      if ((_ref = this._objects) == null) {
        this._objects = {};
      }
      return this._objects[ref] = Material.createShader(ShaderLib.simple, ref);
    };

    ShaderHandler.prototype.update = function(ref, config) {
      var promises,
        _this = this;
      console.log("Updating shader " + ref);
      promises = [this.getConfig(config.vshaderRef), this.getConfig(config.fshaderRef)];
      return RSVP.all(promises).then(function(shaders) {
        var fshader, object, shaderDefinition, vshader, _ref, _ref1;
        vshader = shaders[0], fshader = shaders[1];
        if (!vshader) {
          console.warn('Vertex shader', config.vshaderRef, 'in shader', ref, 'not found');
          return;
        }
        if (!fshader) {
          console.warn('Fragment shader', config.fshaderRef, 'in shader', ref, 'not found');
          return;
        }
        shaderDefinition = {
          attributes: (_ref = config.attributes) != null ? _ref : {},
          uniforms: (_ref1 = config.uniforms) != null ? _ref1 : {},
          vshader: vshader,
          fshader: fshader
        };
        return object = Material.createShader(shaderDefinition, ref);
      });
    };

    return ShaderHandler;

  })(ConfigHandler);
  return MeshRendererComponentHandler = (function(_super) {

    __extends(MeshRendererComponentHandler, _super);

    function MeshRendererComponentHandler() {
      return MeshRendererComponentHandler.__super__.constructor.apply(this, arguments);
    }

    MeshRendererComponentHandler._register('meshRenderer');

    MeshRendererComponentHandler.prototype._prepare = function(config) {
      return _.defaults(config, {
        materialRefs: [],
        cullMode: 'Dynamic',
        castShadows: false,
        receiveShadows: false
      });
    };

    MeshRendererComponentHandler.prototype._create = function(entity, config) {
      var component;
      component = new MeshRendererComponent();
      entity.setComponent(component);
      return component;
    };

    MeshRendererComponentHandler.prototype.update = function(entity, config) {
      var component, materialRef, materialRefs, promise, promises, _fn, _i, _len,
        _this = this;
      component = MeshRendererComponentHandler.__super__.update.call(this, entity, config);
      materialRefs = config.materialRefs;
      if (!materialRefs || materialRefs.length === 0) {
        console.log("No material refs");
        promise = pu.dummyPromise([]);
      } else {
        promises = [];
        _fn = function(materialRef) {
          return promises.push(_this._getMaterial(materialRef));
        };
        for (_i = 0, _len = materialRefs.length; _i < _len; _i++) {
          materialRef = materialRefs[_i];
          _fn(materialRef);
        }
        promise = RSVP.all(promises);
      }
      return promise.then(function(materials) {
        var key, value;
        component.materials = materials;
        for (key in config) {
          value = config[key];
          if (key !== 'materials' && component.hasOwnProperty(key)) {
            component[key] = _.clone(value);
          }
        }
        return component;
      }).then(null, function(err) {
        return console.error("Error handling materials " + err);
      });
    };

    MeshRendererComponentHandler.prototype._getMaterial = function(ref) {
      var _this = this;
      console.log("GetMaterial " + ref);
      return this.getConfig(ref).then(function(config) {
        return _this.updateObject(ref, config, _this.options);
      });
    };

    return MeshRendererComponentHandler;

  })(ComponentHandler);
});
