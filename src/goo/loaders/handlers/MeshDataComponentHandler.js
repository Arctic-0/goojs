// Generated by CoffeeScript 1.6.2
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['goo/loaders/handlers/ComponentHandler', 'goo/renderer/MeshData', 'goo/entities/components/MeshDataComponent', 'goo/loaders/JsonUtils', 'goo/util/rsvp', 'goo/util/PromiseUtil', 'goo/util/ConsoleUtil', 'goo/lib/underscore'], function(ComponentHandler, MeshData, MeshDataComponent, JsonUtils, RSVP, pu, console) {
  var MeshDataComponentHandler, _ref;

  return MeshDataComponentHandler = (function(_super) {
    __extends(MeshDataComponentHandler, _super);

    function MeshDataComponentHandler() {
      _ref = MeshDataComponentHandler.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    MeshDataComponentHandler._register('meshData');

    MeshDataComponentHandler.prototype._prepare = function(config) {
      return _.defaults(config, {
        meshRef: null
      });
    };

    MeshDataComponentHandler.prototype._create = function(entity, config) {};

    MeshDataComponentHandler.prototype.update = function(entity, config) {
      var _this = this;

      MeshDataComponentHandler.__super__.update.call(this, entity, config);
      return this.getConfig(config.meshRef).then(function(mesh) {
        var component, compression, meshData;

        if (mesh.compression && mesh.compression.compressed) {
          compression = {
            compressedVertsRange: mesh.compression.compressedVertsRange || (1 << 14) - 1,
            compressedColorsRange: mesh.compression.compressedColorsRange || (1 << 8) - 1,
            compressedUnitVectorRange: mesh.compression.compressedUnitVectorRange || (1 << 10) - 1
          };
        }
        if (mesh.type === 'SkinnedMesh') {
          meshData = _this._parseMeshData(mesh.data || mesh, 4, 'SkinnedMesh');
          meshData.type = MeshData.SKINMESH;
        } else {
          meshData = _this._parseMeshData(mesh.data || mesh, 0, 'Mesh');
          meshData.type = MeshData.MESH;
        }
        component = new MeshDataComponent(meshData);
        entity.setComponent(component);
        if (mesh.pose) {
          console.warn("SkeletonLoader is not yet supported");
        }
        return component;
      });
    };

    MeshDataComponentHandler.prototype._parseMeshData = function(data, weightsPerVert, type, compression) {
      var attributeMap, buffer, indexCount, jointData, jointIdx, jointIndex, localIndex, localJointMap, localMap, meshData, offset, offsetObj, scale, texCoords, texIdx, texObj, textureUnits, vertexCount, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref1, _ref2, _ref3, _ref4;

      vertexCount = data.vertexCount;
      if (vertexCount === 0) {
        return null;
      }
      indexCount = ((_ref1 = data.indexLengths) != null ? _ref1[0] : void 0) || ((_ref2 = data.indices) != null ? _ref2.length : void 0) || 0;
      attributeMap = {};
      if (data.vertices) {
        attributeMap.POSITION = MeshData.createAttribute(3, 'Float');
      }
      if (data.normals) {
        attributeMap.NORMAL = MeshData.createAttribute(3, 'Float');
      }
      if (data.tangents) {
        attributeMap.TANGENT = MeshData.createAttribute(4, 'Float');
      }
      if (data.colors) {
        attributeMap.COLOR = MeshData.createAttribute(4, 'Float');
      }
      if (weightsPerVert > 0 && data.weights) {
        attributeMap.WEIGHTS = MeshData.createAttribute(4, 'Float');
      }
      if (weightsPerVert > 0 && data.joints) {
        attributeMap.JOINTIDS = MeshData.createAttribute(4, 'Short');
      }
      if (data.textureCoords) {
        _ref3 = data.textureCoords;
        for (texIdx = _i = 0, _len = _ref3.length; _i < _len; texIdx = ++_i) {
          texCoords = _ref3[texIdx];
          console.log("TEXCOORD " + texIdx);
          attributeMap['TEXCOORD' + texIdx] = MeshData.createAttribute(2, 'Float');
        }
      }
      console.log("Parsing mesh data: " + (_.keys(attributeMap).join(',')));
      meshData = new MeshData(attributeMap, vertexCount, indexCount);
      if (data.vertices) {
        if (compression != null) {
          offsetObj = data.vertexOffsets;
          JsonUtils.fillAttributeBufferFromCompressedString(data.vertices, meshData, MeshData.POSITION, [data.vertexScale, data.vertexScale, data.vertexScale], [offsetObj.xOffset, offsetObj.yOffset, offsetObj.zOffset]);
        } else {
          JsonUtils.fillAttributeBuffer(data.vertices, meshData, MeshData.POSITION);
        }
      }
      if (weightsPerVert > 0 && data.weights) {
        if (compression != null) {
          offset = 0;
          scale = 1 / compression.compressedVertsRange;
          JsonUtils.fillAttributeBufferFromCompressedString(data.weights, meshData, MeshData.WEIGHTS, [scale], [offset]);
        } else {
          JsonUtils.fillAttributeBuffer(data.weights, meshData, MeshData.WEIGHTS);
        }
      }
      if (data.normals) {
        if (compression != null) {
          offset = 1 - (compression.compressedUnitVectorRange + 1 >> 1);
          scale = 1 / -offset;
          JsonUtils.fillAttributeBufferFromCompressedString(data.normals, meshData, MeshData.NORMAL, [scale, scale, scale], [offset, offset, offset]);
        } else {
          JsonUtils.fillAttributeBuffer(data.normals, meshData, MeshData.NORMAL);
        }
      }
      if (data.tangents) {
        if (compression != null) {
          offset = 1 - (compression.compressedUnitVectorRange + 1 >> 1);
          scale = 1 / -offset;
          JsonUtils.fillAttributeBufferFromCompressedString(data.tangents, meshData, MeshData.TANGENT, [scale, scale, scale, scale], [offset, offset, offset, offset]);
        } else {
          JsonUtils.fillAttributeBuffer(data.tangents, meshData, MeshData.TANGENT);
        }
      }
      if (data.colors) {
        if (compression != null) {
          offset = 0;
          scale = 255 / (compression.compressedColorsRange + 1);
          JsonUtils.fillAttributeBufferFromCompressedString(data.colors, meshData, MeshData.COLOR, [scale, scale, scale, scale], [offset, offset, offset, offset]);
        } else {
          JsonUtils.fillAttributeBuffer(data.colors, meshData, MeshData.COLOR);
        }
      }
      if (data.textureCoords) {
        textureUnits = data.textureCoords;
        if (compression != null) {
          for (texIdx = _j = 0, _len1 = textureUnits.length; _j < _len1; texIdx = ++_j) {
            texObj = textureUnits[texIdx];
            JsonUtils.fillAttributeBufferFromCompressedString(texObj.UVs, meshData, 'TEXCOORD' + texIdx, texObj.UVScales, texObj.UVOffsets);
          }
        } else {
          for (texIdx = _k = 0, _len2 = textureUnits.length; _k < _len2; texIdx = ++_k) {
            texObj = textureUnits[texIdx];
            JsonUtils.fillAttributeBuffer(texObj, meshData, 'TEXCOORD' + texIdx);
          }
        }
      }
      if (weightsPerVert > 0 && data.joints) {
        buffer = meshData.getAttributeBuffer(MeshData.JOINTIDS);
        if (compression) {
          jointData = JsonUtils.getIntBufferFromCompressedString(data.joints, 32767);
        } else {
          jointData = JsonUtils.getIntBuffer(data.joints, 32767);
        }
        if (type === 'SkinnedMesh') {
          localJointMap = [];
          localIndex = 0;
          for (_l = 0, _len3 = jointData.length; _l < _len3; _l++) {
            jointIndex = jointData[_l];
            if (localJointMap[jointIndex] === void 0) {
              localJointMap[jointIndex] = localIndex++;
            }
            buffer.set([localJointMap[jointIndex]], i);
          }
          localMap = [];
          for (jointIndex = _m = 0, _len4 = localJointMap.length; _m < _len4; jointIndex = ++_m) {
            localIndex = localJointMap[jointIndex];
            localIndex = localJointMap[jointIndex];
            if (localIndex !== null) {
              localMap[localIndex] = jointIndex;
            }
          }
          meshData.paletteMap = localMap;
          meshData.weightsPerVertex = weightsPerVert;
        } else {
          for (jointIdx = _n = 0, _ref4 = jointData.capacity(); 0 <= _ref4 ? _n < _ref4 : _n > _ref4; jointIdx = 0 <= _ref4 ? ++_n : --_n) {
            buffer.putCast(jointIdx, jointData.get(jointIdx));
          }
        }
      }
      if (data.indices) {
        if (compression != null) {
          meshData.getIndexBuffer().set(JsonUtils.getIntBufferFromCompressedString(data.indices, vertexCount));
        } else {
          meshData.getIndexBuffer().set(JsonUtils.getIntBuffer(data.indices, vertexCount));
        }
      }
      if (data.indexModes) {
        meshData.indexModes = data.indexModes.slice(0);
      }
      if (data.indexLengths) {
        meshData.indexLengths = data.indexLengths.slice(0);
      }
      if (data.boundingBox) {
        meshData.boundingBox = data.boundingBox;
      }
      return meshData;
    };

    return MeshDataComponentHandler;

  })(ComponentHandler);
});
