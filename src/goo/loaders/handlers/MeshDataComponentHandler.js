// Generated by CoffeeScript 1.4.0
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['goo/loaders/handlers/ConfigHandler', 'goo/loaders/handlers/ComponentHandler', 'goo/renderer/MeshData', 'goo/entities/components/MeshDataComponent', 'goo/loaders/JsonUtils', 'goo/util/rsvp', 'goo/util/PromiseUtil', 'goo/util/ObjectUtil'], function(ConfigHandler, ComponentHandler, MeshData, MeshDataComponent, JsonUtils, RSVP, pu, _) {
  var MeshDataComponentHandler, MeshDataHandler;
  MeshDataHandler = (function(_super) {

    __extends(MeshDataHandler, _super);

    function MeshDataHandler() {
      return MeshDataHandler.__super__.constructor.apply(this, arguments);
    }

    MeshDataHandler._register('mesh');

    MeshDataHandler.prototype._create = function(meshConfig) {
      var compression, meshData;
      if (meshConfig.compression && meshConfig.compression.compressed) {
        compression = {
          compressedVertsRange: meshConfig.compression.compressedVertsRange || (1 << 14) - 1,
          compressedColorsRange: meshConfig.compression.compressedColorsRange || (1 << 8) - 1,
          compressedUnitVectorRange: meshConfig.compression.compressedUnitVectorRange || (1 << 10) - 1
        };
      }
      if (meshConfig.type === 'SkinnedMesh') {
        meshData = this._parseMeshData(meshConfig.data || meshConfig, 4, 'SkinnedMesh');
        meshData.type = MeshData.SKINMESH;
      } else {
        meshData = this._parseMeshData(meshConfig.data || meshConfig, 0, 'Mesh');
        meshData.type = MeshData.MESH;
      }
      if (meshConfig.pose) {
        console.warn("SkeletonLoader is not yet supported");
      }
      return meshData;
    };

    MeshDataHandler.prototype.update = function(ref, config) {
      var meshData;
      meshData = this._create(config);
      return pu.dummyPromise(meshData);
    };

    MeshDataHandler.prototype._parseMeshData = function(data, weightsPerVert, type, compression) {
      var attributeMap, buffer, indexCount, jointData, jointIdx, jointIndex, localIndex, localJointMap, localMap, meshData, offset, offsetObj, scale, texCoords, texIdx, texObj, textureUnits, vertexCount, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref, _ref1, _ref2, _ref3;
      vertexCount = data.vertexCount;
      if (vertexCount === 0) {
        return null;
      }
      indexCount = ((_ref = data.indexLengths) != null ? _ref[0] : void 0) || ((_ref1 = data.indices) != null ? _ref1.length : void 0) || 0;
      attributeMap = {};
      if (data.vertices) {
        attributeMap.POSITION = MeshData.createAttribute(3, 'Float');
      }
      if (data.normals) {
        attributeMap.NORMAL = MeshData.createAttribute(3, 'Float');
      }
      if (data.tangents) {
        attributeMap.TANGENT = MeshData.createAttribute(4, 'Float');
      }
      if (data.colors) {
        attributeMap.COLOR = MeshData.createAttribute(4, 'Float');
      }
      if (weightsPerVert > 0 && data.weights) {
        attributeMap.WEIGHTS = MeshData.createAttribute(4, 'Float');
      }
      if (weightsPerVert > 0 && data.joints) {
        attributeMap.JOINTIDS = MeshData.createAttribute(4, 'Short');
      }
      if (data.textureCoords) {
        _ref2 = data.textureCoords;
        for (texIdx = _i = 0, _len = _ref2.length; _i < _len; texIdx = ++_i) {
          texCoords = _ref2[texIdx];
          console.log("TEXCOORD " + texIdx);
          attributeMap['TEXCOORD' + texIdx] = MeshData.createAttribute(2, 'Float');
        }
      }
      console.log("Parsing mesh data: " + (_.keys(attributeMap).join(',')));
      meshData = new MeshData(attributeMap, vertexCount, indexCount);
      if (data.vertices) {
        if (compression != null) {
          offsetObj = data.vertexOffsets;
          JsonUtils.fillAttributeBufferFromCompressedString(data.vertices, meshData, MeshData.POSITION, [data.vertexScale, data.vertexScale, data.vertexScale], [offsetObj.xOffset, offsetObj.yOffset, offsetObj.zOffset]);
        } else {
          JsonUtils.fillAttributeBuffer(data.vertices, meshData, MeshData.POSITION);
        }
      }
      if (weightsPerVert > 0 && data.weights) {
        if (compression != null) {
          offset = 0;
          scale = 1 / compression.compressedVertsRange;
          JsonUtils.fillAttributeBufferFromCompressedString(data.weights, meshData, MeshData.WEIGHTS, [scale], [offset]);
        } else {
          JsonUtils.fillAttributeBuffer(data.weights, meshData, MeshData.WEIGHTS);
        }
      }
      if (data.normals) {
        if (compression != null) {
          offset = 1 - (compression.compressedUnitVectorRange + 1 >> 1);
          scale = 1 / -offset;
          JsonUtils.fillAttributeBufferFromCompressedString(data.normals, meshData, MeshData.NORMAL, [scale, scale, scale], [offset, offset, offset]);
        } else {
          JsonUtils.fillAttributeBuffer(data.normals, meshData, MeshData.NORMAL);
        }
      }
      if (data.tangents) {
        if (compression != null) {
          offset = 1 - (compression.compressedUnitVectorRange + 1 >> 1);
          scale = 1 / -offset;
          JsonUtils.fillAttributeBufferFromCompressedString(data.tangents, meshData, MeshData.TANGENT, [scale, scale, scale, scale], [offset, offset, offset, offset]);
        } else {
          JsonUtils.fillAttributeBuffer(data.tangents, meshData, MeshData.TANGENT);
        }
      }
      if (data.colors) {
        if (compression != null) {
          offset = 0;
          scale = 255 / (compression.compressedColorsRange + 1);
          JsonUtils.fillAttributeBufferFromCompressedString(data.colors, meshData, MeshData.COLOR, [scale, scale, scale, scale], [offset, offset, offset, offset]);
        } else {
          JsonUtils.fillAttributeBuffer(data.colors, meshData, MeshData.COLOR);
        }
      }
      if (data.textureCoords) {
        textureUnits = data.textureCoords;
        if (compression != null) {
          for (texIdx = _j = 0, _len1 = textureUnits.length; _j < _len1; texIdx = ++_j) {
            texObj = textureUnits[texIdx];
            JsonUtils.fillAttributeBufferFromCompressedString(texObj.UVs, meshData, 'TEXCOORD' + texIdx, texObj.UVScales, texObj.UVOffsets);
          }
        } else {
          for (texIdx = _k = 0, _len2 = textureUnits.length; _k < _len2; texIdx = ++_k) {
            texObj = textureUnits[texIdx];
            JsonUtils.fillAttributeBuffer(texObj, meshData, 'TEXCOORD' + texIdx);
          }
        }
      }
      if (weightsPerVert > 0 && data.joints) {
        buffer = meshData.getAttributeBuffer(MeshData.JOINTIDS);
        if (compression) {
          jointData = JsonUtils.getIntBufferFromCompressedString(data.joints, 32767);
        } else {
          jointData = JsonUtils.getIntBuffer(data.joints, 32767);
        }
        if (type === 'SkinnedMesh') {
          localJointMap = [];
          localIndex = 0;
          for (_l = 0, _len3 = jointData.length; _l < _len3; _l++) {
            jointIndex = jointData[_l];
            if (localJointMap[jointIndex] === void 0) {
              localJointMap[jointIndex] = localIndex++;
            }
            buffer.set([localJointMap[jointIndex]], i);
          }
          localMap = [];
          for (jointIndex = _m = 0, _len4 = localJointMap.length; _m < _len4; jointIndex = ++_m) {
            localIndex = localJointMap[jointIndex];
            localIndex = localJointMap[jointIndex];
            if (localIndex !== null) {
              localMap[localIndex] = jointIndex;
            }
          }
          meshData.paletteMap = localMap;
          meshData.weightsPerVertex = weightsPerVert;
        } else {
          for (jointIdx = _n = 0, _ref3 = jointData.capacity(); 0 <= _ref3 ? _n < _ref3 : _n > _ref3; jointIdx = 0 <= _ref3 ? ++_n : --_n) {
            buffer.putCast(jointIdx, jointData.get(jointIdx));
          }
        }
      }
      if (data.indices) {
        if (compression != null) {
          meshData.getIndexBuffer().set(JsonUtils.getIntBufferFromCompressedString(data.indices, vertexCount));
        } else {
          meshData.getIndexBuffer().set(JsonUtils.getIntBuffer(data.indices, vertexCount));
        }
      }
      if (data.indexModes) {
        meshData.indexModes = data.indexModes.slice(0);
      }
      if (data.indexLengths) {
        meshData.indexLengths = data.indexLengths.slice(0);
      }
      if (data.boundingBox) {
        meshData.boundingBox = data.boundingBox;
      }
      return meshData;
    };

    return MeshDataHandler;

  })(ConfigHandler);
  return MeshDataComponentHandler = (function(_super) {

    __extends(MeshDataComponentHandler, _super);

    function MeshDataComponentHandler() {
      return MeshDataComponentHandler.__super__.constructor.apply(this, arguments);
    }

    MeshDataComponentHandler._register('meshData');

    MeshDataComponentHandler.prototype._prepare = function(config) {
      return _.defaults(config, {
        meshRef: null
      });
    };

    MeshDataComponentHandler.prototype._create = function(entity, config) {};

    MeshDataComponentHandler.prototype.update = function(entity, config) {
      var meshRef,
        _this = this;
      MeshDataComponentHandler.__super__.update.call(this, entity, config);
      meshRef = config.meshRef;
      return this.getConfig(meshRef).then(function(config) {
        return _this.updateObject(meshRef, config).then(function(meshData) {
          var component;
          component = new MeshDataComponent(meshData);
          entity.setComponent(component);
          return component;
        });
      });
    };

    return MeshDataComponentHandler;

  })(ComponentHandler);
});
