// Generated by CoffeeScript 1.6.2
var __hasProp = {}.hasOwnProperty;

define(['goo/loaders/handlers/ConfigHandler', 'goo/loaders/handlers/ComponentHandler', 'goo/loaders/Loader', 'goo/renderer/TextureCreator', 'goo/util/rsvp', 'goo/util/StringUtil', 'goo/util/PromiseUtil', 'goo/util/ConsoleUtil', 'goo/loaders/handlers/SceneHandler', 'goo/loaders/handlers/EntityHandler', 'goo/loaders/handlers/CameraComponentHandler', 'goo/loaders/handlers/LightComponentHandler', 'goo/loaders/handlers/MeshDataComponentHandler', 'goo/loaders/handlers/MeshRendererComponentHandler', 'goo/loaders/handlers/TransformComponentHandler'], function(ConfigHandler, ComponentHandler, Loader, TextureCreator, RSVP, su, pu, console) {
  /**
  	* @class Class to load scenes into the world, or to update the scene/world based on the data model.
  	*
  	* @constructor
  	* @param {object} parameters
  	* @param {World} parameters.world The target World object.
  	* @param {Loader} [parameters.loader]
  	* @param {string} [parameters.rootPath] The root path where to get resources. Either <code>parameters.rootPath</code> or <code>parameters.loader</code> must be defined.
  	*
  */

  var DynamicLoader;

  return DynamicLoader = (function() {
    function DynamicLoader(options) {
      this._world = options.world || (function() {
        throw new Error("World argument cannot be null");
      })();
      if (options.loader) {
        this._loader = options.loader;
      } else if (options.rootPath) {
        this._loader = new Loader({
          rootPath: options.rootPath
        });
      } else {
        throw new Error("parameters.rootPath or parameters.loader must be defined");
      }
      this._configs = {};
      this._textureCreator = new TextureCreator({
        loader: this._loader
      });
    }

    /**
    		* Load an object with the specified path into the world. The object can be of any
    		* type, what loading does is determined by the registered {ConfigHandler}
    		* 
    		* @param {string} ref Ref of object to load
    		* @returns {RSVP.Promise} The promise is resolved when the object is loaded into the world, with the config data as argument.
    		*
    */


    DynamicLoader.prototype.load = function(ref) {
      return this.update(ref, null);
    };

    /**
    		* Update an object in the world with an updated config. The object can be of any
    		* type, updating behavior is determined by the registered {ConfigHandler}
    		* 
    		* @param {string} ref Ref of object to update
    		* @param {object} [config] New configuration (formatted according to data model). If omitted, works the same as {DynamicLoader.load}.
    		* @returns {RSVP.Promise} The promise is resolved when the object is updated, with the config data as argument.
    		*
    */


    DynamicLoader.prototype.update = function(ref, config) {
      var _this = this;

      console.log("Loading/updating " + ref);
      if (config) {
        this._configs[ref] = config;
      }
      this._objects = {};
      return this._loadRef(ref).then(function(config) {
        var childRef, promises, _fn, _i, _len, _ref;

        promises = [];
        _ref = _this._getRefsFromConfig(config);
        _fn = function(childRef) {
          return promises.push(_this._loadRef(childRef).then(function(childConfig) {
            return _this._handle(childRef, childConfig);
          }));
        };
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          childRef = _ref[_i];
          _fn(childRef);
        }
        promises.push(_this._handle(ref, config));
        return RSVP.all(promises);
      }).then(function() {
        return _this._configs;
      }).then(null, function(err) {
        return console.error("Error updating " + ref + " " + err);
      });
    };

    DynamicLoader.prototype._handle = function(ref, config, noCache) {
      var handler, handlerClass, textureObj, type, _ref, _ref1,
        _this = this;

      if (noCache == null) {
        noCache = false;
      }
      if ((_ref = this._objects[ref]) != null ? _ref.then : void 0) {
        return this._objects[ref];
      } else if (this._objects[ref] && !noCache) {
        return pu.dummyPromise(this._objects[ref]);
      } else {
        type = this._getTypeForRef(ref);
        if (type === "texture") {
          textureObj = this._objects[ref] = this._textureCreator.loadTexture2D(config.url);
          return pu.dummyPromise(textureObj);
        } else {
          handlerClass = ConfigHandler.getHandler(type);
          if (handlerClass) {
            if ((_ref1 = this._handlers) == null) {
              this._handlers = {};
            }
            handler = this._handlers[type];
            if (handler) {
              handler.world = this._world;
              handler.getConfig = this._loadRef.bind(this);
            } else {
              handler = this._handlers[type] = new handlerClass(this._world, this._loadRef.bind(this), this._handle.bind(this));
            }
            console.log("Handling " + ref);
            return this._objects[ref] = handler.update(ref, config).then(function(object) {
              return _this._objects[ref] = object;
            });
          } else {
            console.warn("No handler for type " + type);
            return pu.dummyPromise(null);
          }
        }
      }
    };

    /**
    		* Fetch a file from the server, and parse JSON if needed. 
    		*
    		* @param {string} ref Ref of the config to load
    		* @param {boolean} [noCache] If true, ignore cached config and fetch everything from the server
    		* @returns {RSVP.Promise} Promise that resolves with the loaded config
    		*
    */


    DynamicLoader.prototype._loadRef = function(ref, noCache) {
      var _ref,
        _this = this;

      if (noCache == null) {
        noCache = false;
      }
      if ((_ref = this._configs[ref]) != null ? _ref.then : void 0) {
        return this._configs[ref];
      } else if ((this._configs[ref] != null) && !noCache) {
        return pu.dummyPromise(this._configs[ref]);
      } else {
        return this._configs[ref] = this._loader.load(ref, function(data) {
          var e, output;

          try {
            return output = JSON.parse(data);
          } catch (_error) {
            e = _error;
            return output = data;
          } finally {
            _this._configs[ref] = output;
          }
        });
      }
    };

    DynamicLoader.prototype._getRefsFromConfig = function(config) {
      var traverse, _refs;

      _refs = [];
      traverse = function(key, value) {
        var _key, _results, _value;

        if (su.endsWith(key, 'Refs')) {
          return _refs = _refs.concat(value);
        } else if (su.endsWith(key, 'Ref')) {
          return _refs.push(value);
        } else if (value instanceof Object) {
          _results = [];
          for (_key in value) {
            if (!__hasProp.call(value, _key)) continue;
            _value = value[_key];
            _results.push(traverse(_key, _value));
          }
          return _results;
        }
      };
      traverse("", config);
      return _refs;
    };

    DynamicLoader.prototype._getTypeForRef = function(ref) {
      return ref.split('.').pop();
    };

    return DynamicLoader;

  })();
});
